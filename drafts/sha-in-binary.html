<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Stamping Git SHAs into Your Binaries | commentout.net</title>
        <meta charset="utf-8" />
        <link rel="stylesheet" type="text/css" href="/theme/css/style.css" />
        <link rel="stylesheet" type="text/css" href="/theme/css/pygment.css" />
        <link href="https://fonts.googleapis.com/css?family=Inconsolata|PT+Sans|PT+Serif" rel="stylesheet">
    </head>
    <body>
        <div id="box">
            <header>
                <img src="/theme/images/top_img.jpg" width="100%"> 
            </header>
            <nav>
                <a href="https://commentout.net"><div id="home"># comment out</div></a>
                <ul>
                    <a href="https://commentout.net"><li>Blog</li></a>
                    <a href="/pages/about-me.html"><li>About</li></a>
                </ul>
            </nav>
            <main>

<section id="content" class="body">
    <h1 class="article-title">Stamping Git SHAs into Your Binaries</h1>
    <h2 class="article-subtitle"></h2>
    <span class="article-date">2017. May. 08</span>

    <div class="article-content">
        <p>Have you ever looked at a binary from a project you wrote and asked, "Where the hell
did this build come from?" Well, I'm about to make your life (and the lives of your
customers) a bit easier. I'm going to show you how to write the Git SHA1 for each
commit directly into the resulting binaries.</p>
<p>If your build is anything like Roslyn you may have a half dozen different branches,
each with their own little modifications, each of which get built occasionally for
testing or prerelease validation. Often I'll find Roslyn binaries randomly floating
in a share somewhere or attached to a bug report with little to no context. While
we do have carefully incremented version numbers in our builds, it can be a challenge
to even reverse engineer a version into a specific source code commit. If each branch
doesn't have its own versioning scheme it's even possible that two branches could
produce binaries with the exact same version, even if they came from completely
different source code. Solution: write the commit SHA directly into the binary. This
guide will be targeted at people building .NET applications, but I'll give general
advice where applicable and you can choose what makes sense for your software.</p>
<p>The first question is, where in the binary do we write the SHA? My answer is: wherever
it's easiest to see. For console programs, that may mean including the SHA in the output
from a <code>--version</code> flag. For most programs, I think the file metadata, as displayed by
a common file system browser on your preferred OS, is the most accessible tag. Specifically,
for .NET programs I like using the <code>AssemblyInformationalVersionAttribute</code>. This tag</p>
<ol>
<li>Is only specified as a block of text, making it perfect for human-readable unstructured
     data.</li>
<li>Is viewable by default in the Windows File Explorer both in the file listing view
     and in the properties window.</li>
<li>Is easily accessible by .NET code via reflection.</li>
</ol>
<p>Here's what it looks like in File Explorer with details expanded:</p>
<p><img alt="File explorer screenshot" src="https://commentout.net/images/file-xplore.jpg" /></p>
<p>For Unix-like systems I would probably try to use extended file attributes, although
an exact analog is hard to come by because this is not exactly standardized across POSIX
systems.</p>
<p>Once you've figured out where to put the SHA, you need to retrieve the SHA in the first
place. Now I know what you're thinking: "well that's easy, I'll just shell out to git
and run a quick <code>git rev-parse HEAD</code>...". Nuh-uh. Let's assume that Git is installed on
the machine -- what makes you think it's available on the path? As I found out quite
quickly when I implemented this for Roslyn, there are a lot of instances where someone
may be building your code (like in a build lab) that checks out the Git repository, but
doesn't build with Git on the path. Instead, I found that the most robust method is to
either pass the SHA through an environment variable generated by the build environment,
or to grab the SHA directly out of the Git object directory. Don't worry, I won't let
you leave you flailing; here's the Roslyn MSBuild logic for finding and reading the
Git SHA (sorry about the XML)</p>
<div class="highlight"><pre><span></span><span class="nt">&lt;When</span> <span class="na">Condition=</span><span class="s">&quot;&#39;$(BUILD_SOURCEVERSION)&#39; != &#39;&#39;&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;PropertyGroup&gt;</span>
    <span class="nt">&lt;GitHeadSha&gt;</span>$(BUILD_SOURCEVERSION)<span class="nt">&lt;/GitHeadSha&gt;</span>
  <span class="nt">&lt;/PropertyGroup&gt;</span>
<span class="nt">&lt;/When&gt;</span>
<span class="nt">&lt;When</span> <span class="na">Condition=</span><span class="s">&quot;&#39;$(BUILD_SOURCEVERSION)&#39; == &#39;&#39; AND &#39;$(GIT_COMMIT)&#39; != &#39;&#39;&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;PropertyGroup&gt;</span>
    <span class="nt">&lt;GitHeadSha&gt;</span>$(GIT_COMMIT)<span class="nt">&lt;/GitHeadSha&gt;</span>
  <span class="nt">&lt;/PropertyGroup&gt;</span>
<span class="nt">&lt;/When&gt;</span>
<span class="nt">&lt;Otherwise&gt;</span>
  <span class="nt">&lt;PropertyGroup&gt;</span>
    <span class="nt">&lt;GitHeadSha&gt;</span>Not found<span class="nt">&lt;/GitHeadSha&gt;</span>
    <span class="nt">&lt;DotGitDir&gt;</span>$([System.IO.Path]::GetFullPath(&#39;$(MSBuildThisFileDirectory)../../.git&#39;))<span class="nt">&lt;/DotGitDir&gt;</span>
    <span class="nt">&lt;HeadFileContent</span> <span class="na">Condition=</span><span class="s">&quot;Exists(&#39;$(DotGitDir)/HEAD&#39;)&quot;</span><span class="nt">&gt;</span>$([System.IO.File]::ReadAllText(&#39;$(DotGitDir)/HEAD&#39;).Trim())<span class="nt">&lt;/HeadFileContent&gt;</span>
    <span class="nt">&lt;RefPath</span> <span class="na">Condition=</span><span class="s">&quot;$(HeadFileContent.StartsWith(&#39;ref: &#39;))&quot;</span><span class="nt">&gt;</span>$(DotGitDir)/$(HeadFileContent.Substring(5))<span class="nt">&lt;/RefPath&gt;</span>
    <span class="nt">&lt;GitHeadSha</span> <span class="na">Condition=</span><span class="s">&quot;&#39;$(RefPath)&#39; != &#39;&#39; AND Exists(&#39;$(RefPath)&#39;)&quot;</span><span class="nt">&gt;</span>$([System.IO.File]::ReadAllText(&#39;$(RefPath)&#39;).Trim())<span class="nt">&lt;/GitHeadSha&gt;</span>
    <span class="nt">&lt;GitHeadSha</span> <span class="na">Condition=</span><span class="s">&quot;&#39;$(HeadFileContent)&#39; != &#39;&#39; AND &#39;$(RefPath)&#39; == &#39;&#39;&quot;</span><span class="nt">&gt;</span>$(HeadFileContent)<span class="nt">&lt;/GitHeadSha&gt;</span>
  <span class="nt">&lt;/PropertyGroup&gt;</span>
<span class="nt">&lt;/Otherwise&gt;</span>
</pre></div>


<p>It's  a little verbose, but should be pretty straight-forward. We first try to
read the SHA directly out of the refs file in <code>.git/HEAD</code> prefixed with the
text <code>ref:</code>. Otherwise we assume a format called a "packed ref", which
you can look up in the Git docs. It's basically a pointer to another file,
so we just read the new file and use the content from the second file. With
that I'll leave you to try this yourself -- and hopefully your days of playing
source-code-detective are over.</p>
    </div>
</section>

            </main>
            <footer>
            </footer>
        </div>
    </body>
</html>